dataset:
  name: COCO # 或 PASCAL_VOC 等
  # 假设已使用 prepare_detection_data.py 生成 LR/ 和 annotations.json 的父目录
  image_dir: "dataset/date_prepared" # <--- 修改: 临时训练集 LR 图像父目录
  annotation_file: "dataset/date_prepared/annotations.json" # <--- 修改: 临时训练集调整后的标注文件
  scale_factor: 4 # <--- 修改: 必须与 SR 模型匹配

# Model Configuration
model:
  # ConditionalSR 子模块参数 (应与 stage2 匹配)
  sr_fast:
    in_channels: 3
    d: 56
    s: 12
    m: 4
    scale_factor: 4
  sr_quality:
    in_channels: 3
    num_channels: 64
    num_blocks: 16
    scale_factor: 4
  masker:
    in_channels: 3
    base_channels: 32
    num_blocks: 4
    output_channels: 1 # 输出单通道 logits
    output_patch_size: 16 # Masker 输出相对于 LR 输入的下采样因子 (粗粒度)
    threshold: 0.5 # 推理时硬掩码的阈值

  # 预训练权重路径
  weights:
    sr_fast: "./temp_checkpoints/stage2_sr/sr_fast_pretrained.pth"
    sr_quality: "./temp_checkpoints/stage2_sr/sr_quality_pretrained.pth"
    masker: null # 如果有预训练 Masker 权重，提供路径
    detector: "./temp_checkpoints/stage1_yolo/yolo_pretrained_hr.pt" # YOLOv8 .pt 权重

  # YOLO 模型特定参数 (新增或确认此结构)
  # 这些参数将用于在 `compute_yolo_loss_from_predictions` 中正确初始化和配置损失计算逻辑
  num_classes: 2 # <--- 新增: 数据集中的类别数量 (例如: block, bolt -> 2)
                 # 这个值应该与您的数据集和YOLO预训练阶段一致
  yolo_params:
    reg_max: 16   # <--- 新增: DFL回归的最大值，通常为16
    strides: [8.0, 16.0, 32.0] # <--- 新增: YOLO检测头的三个输出层的步长

# Training Configuration
train:
  epochs: 2
  batch_size: 2 # <--- 修改: **显著减小批次大小以避免OOM** (例如 2, 4, 8, 根据您的显存调整)

  # 差分学习率配置
  learning_rates:
    high_lr: 0.0001 # 用于 Masker, Detector Head, SR 上采样层等
    low_lr: 0.000001 # 用于 Detector Backbone, SR 主体层等

  # 优化器
  optimizer:
    name: AdamW
    args:
      weight_decay: 0.0005

  # 学习率调度器
  scheduler:
    name: CosineAnnealingLR
    args:
      T_max: 150 # <--- 修改: 应为总 epochs 数，如果 scheduler.step() 是每个 epoch 调用
                 # 如果 scheduler.step() 是每个 step 调用, T_max 应为 total_steps = epochs * steps_per_epoch
      eta_min: 0.0000001

  # 联合损失函数权重 (用于 calculate_joint_loss)
  loss_weights:
    detection: 1.0 # YOLO 检测损失权重 (此权重乘以 compute_yolo_loss_from_predictions 的输出)
    sparsity: 0.1  # 稀疏度损失权重
    smoothness: 0.01 # 掩码平滑度损失权重

  # YOLO 特定损失的超参数 (新增，用于 compute_yolo_loss_from_predictions 内部)
  yolo_hyp:
    box: 7.5  # CIoU + DFL 边界框损失的增益
    cls: 0.5  # 分类损失的增益
    dfl: 1.5  # DFL 部分的增益
    label_smoothing: 0.0 # 标签平滑系数 (通常为0)

  # TaskAlignedAssigner 参数 (新增，用于 compute_yolo_loss_from_predictions 内部)
  yolo_assigner_params:
    topk: 10
    alpha: 0.5 # 用于对齐度量中的分类得分指数
    beta: 6.0  # 用于对齐度量中的IoU指数
    use_ciou_for_tal_metric: False # 在TAL的对齐度量计算中使用CIoU (YOLOv8通常为False, RT-DETR为True)

  # 稀疏度目标 (用于 L_sparsity = mse(mean(mask), target_sparsity_ratio))
  target_sparsity_ratio: 0.2 # 目标 Quality 区域比例

  # Gumbel-Softmax 温度
  gumbel:
    initial_tau: 2.0
    final_tau: 0.5
    anneal_epochs: 50 # <--- 修改: 温度退火的 epoch 数。如果 anneal_steps 未设置或为null，则使用此值。
                     # 例如，如果总共150个epoch，希望在1/3时完成退火，设为50。
    anneal_steps: null # <--- 修改: 温度退火的总步数。如果设置为 null 或未提供，则会使用 anneal_epochs * steps_per_epoch。
                       # 如果您希望精确控制步数，例如总步数是 N，希望在 N/2 步完成退火，则设为 N/2。
                       # 鉴于之前的讨论，如果150个epoch，每个epoch 10 step，总共1500 step。
                       # 如果想在1000步完成退火，这里就写1000。
                       # 当前 anneal_steps: 15000 远大于 1500，会导致温度几乎不变。建议设为 null 或一个更小的值。
    anneal_schedule: "cosine" # 退火策略 (linear, cosine)

  device: "cpu" # 默认使用CPU训练，可通过命令行参数 --use_gpu 覆盖为 "cuda"
  num_workers: 4 # 根据您的CPU核心数和IO调整
  seed: 42
  log_interval_steps: 10 # 每隔多少步记录一次训练日志到 TensorBoard

# Logging and Saving
log_dir: "./temp_logs/stage3_joint"
checkpoint_dir: "./temp_checkpoints/stage3_joint"
# save_interval (step-based) 和 eval_interval (step-based) 由命令行参数控制

# Evaluation (在训练过程中进行)
evaluation:
  # interval (step-based) 由命令行参数控制
  metric: "map" # 主要评估指标
  # 验证集使用与训练集相同的设置 (LR 图像)
  val_image_dir: "dataset/date_prepared" # <--- 修改: 临时验证集 LR 图像父目录
  val_annotation_file: "dataset/date_prepared/annotations.json" # <--- 修改: 临时验证集调整后标注